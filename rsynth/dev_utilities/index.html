<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `dev_utilities` mod in crate `rsynth`."><meta name="keywords" content="rust, rustlang, rust-lang, dev_utilities"><title>rsynth::dev_utilities - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../rsynth/index.html'><div class='logo-container'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Module dev_utilities</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><p class='location'><a href='../index.html'>rsynth</a></p><script>window.sidebarCurrent = {name: 'dev_utilities', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/rsynth/dev_utilities/mod.rs.html#1-408' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../index.html'>rsynth</a>::<wbr><a class="mod" href=''>dev_utilities</a></span></h1><div class='docblock'><p>Utilities to be used when developing backends and middleware.</p>
<h1 id="writing-a-backend" class="section-header"><a href="#writing-a-backend">Writing a backend</a></h1>
<p>Custom backends do not need to be in the <code>rsynth</code> crate, you can write
a backend in a separate crate. If you encounter problems that prevent you
from writing your backend in a separate crate (e.g., we have forgotten to
mark something as <code>pub</code>), let us know by opening an issue.</p>
<h2 id="creating-an-input-buffer-and-an-output-buffer" class="section-header"><a href="#creating-an-input-buffer-and-an-output-buffer">Creating an input buffer and an output buffer</a></h2>
<p>When you pass <code>&amp;[&amp;[f32]]</code> for the input buffer and <code>&amp;mut[&amp;mut[f32]]</code>
for the output buffer, you may face the challenge that you can have
the buffers for each channel and you can <code>collect()</code> them into a <code>Vec</code>,
but you don't want to allocate that <code>Vec</code> in the real-time thread.
In order you to help overcome this problem, we provide
<a href="./vecstorage/index.html"><code>VecStorage</code> and <code>VecStorageMut</code></a>, which you can pre-allocate and re-use for every
call to <code>render_buffer</code> with different lifetimes of the slices.</p>
<h2 id="writing-a-custom-trait-for-a-backend" class="section-header"><a href="#writing-a-custom-trait-for-a-backend">Writing a custom trait for a backend</a></h2>
<p>When the backend needs a special trait to be implemented by the plugin,
ideally all middleware should &quot;pass trough&quot; this trait. The middleware
does this by implementing the <a href="./transparent/trait.Transparent.html"><code>Transparent</code></a> trait. The backend needs
to be able to &quot;look trough&quot; the middleware. This can be achieved by using
a blanket impl as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rsynth</span>::<span class="ident">dev_utilities</span>::<span class="ident">transparent</span>::<span class="ident">Transparent</span>;
<span class="kw">trait</span> <span class="ident">MyCustomTrait</span> {
    <span class="comment">// ...</span>
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">MyCustomTrait</span> <span class="kw">for</span> <span class="ident">T</span>
<span class="kw">where</span>
   <span class="ident">T</span>: <span class="ident">Transparent</span>,
   <span class="op">&lt;</span><span class="ident">T</span> <span class="kw">as</span> <span class="ident">Transparent</span><span class="op">&gt;</span>::<span class="ident">Inner</span>: <span class="ident">MyCustomTrait</span>,
{
    <span class="comment">// ...</span>
}</pre></div>
<h2 id="writing-custom-events" class="section-header"><a href="#writing-custom-events">Writing custom events</a></h2>
<p>See <a href="./index.html#writing-events">&quot;Writing events&quot; below</a>.</p>
<h2 id="publishing-a-backend-crate" class="section-header"><a href="#publishing-a-backend-crate">Publishing a backend crate</a></h2>
<p>When you publish a backend crate, let us know by opening an issue or pull request
so that we can link to it in the documentation of rsynth.</p>
<h1 id="writing-middleware" class="section-header"><a href="#writing-middleware">Writing middleware</a></h1><h2 id="implementing-backend-specific-traits" class="section-header"><a href="#implementing-backend-specific-traits">Implementing backend-specific traits</a></h2>
<p>Some backends might require plugins to implement a trait specific for that
backend. In order to implement this trait for the middleware as well,
you can simply implement the <a href="./transparent/trait.Transparent.html"><code>Transparent</code></a> trait. A blanket impl defined
by the backend will then ensure that the middleware also implements the
backend specific trait.</p>
<h2 id="handling-events" class="section-header"><a href="#handling-events">Handling events</a></h2>
<p>Middleware needs to implement <a href="../event/trait.EventHandler.html"><code>EventHandler</code></a> for &quot;all&quot; events.
If the middleware does not do anything with events at all, it is
easy to simply pass it to the child:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rsynth</span>::<span class="ident">event</span>::<span class="ident">EventHandler</span>;
<span class="kw">struct</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span> {
    <span class="ident">child</span>: <span class="ident">P</span>
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">P</span>: <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">E</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="self">self</span>.<span class="ident">child</span>.<span class="ident">handle_event</span>(<span class="ident">event</span>, <span class="ident">context</span>);
    }
}</pre></div>
<p>When trying to handle one event type in a special way, this no longer
works because Rust does not yet support specialization (at the time of writing):
the following will not compile.</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ<span class='tooltiptext'>This example deliberately fails to compile</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">use</span> <span class="ident">rsynth</span>::<span class="ident">event</span>::<span class="ident">EventHandler</span>;
<span class="kw">struct</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span> {
    <span class="ident">child</span>: <span class="ident">P</span>
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">P</span>: <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">E</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="self">self</span>.<span class="ident">child</span>.<span class="ident">handle_event</span>(<span class="ident">event</span>, <span class="ident">context</span>);
    }
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">SpecialEventType</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
{
    <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">SpecialEventType</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="comment">// Do something specific with the middleware.</span>
    }
}</pre></div>
<p>You can solve this problem in two ways, depending on the type that
you want to handle in a special way. These techniques are supported by the <a href="https://docs.rs/syllogism/0.1.0/syllogism/"><code>syllogism</code></a> crate
and will be described below.
Additionally, we advise to provide support using specialization in addition to the techniques
from the <a href="https://docs.rs/syllogism/0.1.0/syllogism/"><code>syllogism</code></a> crate. This allows you to ensure that your middleware still works when
we would switch from the <a href="https://docs.rs/syllogism/0.1.0/syllogism/"><code>syllogism</code></a> crate to using specializationg, once that gets
stabilized.</p>
<p>In order to support specialization, you can edit tthe <code>Cargo.toml</code> file as follows:</p>
<pre><code class="language-toml">[features]
default=[&quot;stable&quot;]
stable=[&quot;syllogism&quot;, &quot;syllogism-macro&quot;]

[dependencies]
syllogism = {version = &quot;0.1&quot;, optional = true}
syllogism-macro = {version = &quot;0.1&quot;, optional = true}
</code></pre>
<p>In order to support specilization, you can change your source code as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// In the root module:</span>
<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;stable&quot;</span>), <span class="ident">feature</span>(<span class="ident">specialization</span>))]</span>

<span class="comment">// Near the definition of `MyMiddleware`</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;stable&quot;</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="comment">// ...</span>
{
    <span class="ident">default</span> <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">E</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="comment">// The generic implementation.</span>
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;stable&quot;</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">SpecialEventType</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="comment">// ...</span>
{
    <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">SpecialEventType</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="comment">// The specific implementation.</span>
    }
}</pre></div>
<h3 id="specializing-for-events-with-a-concrete-type-using-the-syllogism-crate" class="section-header"><a href="#specializing-for-events-with-a-concrete-type-using-the-syllogism-crate">Specializing for events with a concrete type using the <code>syllogism</code> crate</a></h3>
<p>If the event type for which you want to specialize is a concrete type,
you can use the <a href="https://docs.rs/syllogism/0.1.0/syllogism/trait.IsNot.html"><code>IsNot</code></a> trait from the <a href="https://docs.rs/syllogism/0.1.0/syllogism/"><code>syllogism</code></a> crate to distinguish the generic
types from the special type.
Because no event type should implement <code>IsNot&lt;Self&gt;</code>, the compiler
knows there is no overlap. All event types should implement <code>IsNot&lt;T&gt;</code> for all
other types <code>T</code>. How this is achieved, is explained below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rsynth</span>::<span class="ident">event</span>::<span class="ident">EventHandler</span>;
<span class="kw">use</span> <span class="ident">syllogism</span>::<span class="ident">IsNot</span>;
<span class="kw">struct</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span> {
    <span class="ident">child</span>: <span class="ident">P</span>
}

<span class="comment">// If you are also supporting specialization as described above,</span>
<span class="comment">// this should be behind the `#[cfg(feature = &quot;stable&quot;)]` attribute.</span>

<span class="comment">// The generic event types</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">P</span>: <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> , <span class="ident">E</span>: <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">SpecialEventType</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">E</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="self">self</span>.<span class="ident">child</span>.<span class="ident">handle_event</span>(<span class="ident">event</span>, <span class="ident">context</span>);
    }
}

<span class="comment">// If you are also supporting specialization as described above,</span>
<span class="comment">// this should be behind the `#[cfg(feature = &quot;stable&quot;)]` attribute.</span>

<span class="comment">// The special event type</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">SpecialEventType</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
{
    <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">SpecialEventType</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="comment">// Do something specific with the middleware.</span>
    }
}</pre></div>
<h3 id="specializing-for-events-of-a-type-parameter-using-the-syllogism-crate" class="section-header"><a href="#specializing-for-events-of-a-type-parameter-using-the-syllogism-crate">Specializing for events of a type parameter using the <code>syllogism</code> crate</a></h3>
<p>If the event type for which you want to specialize is a type parameter,
you cannot use the <code>IsNot</code> trait because the compiler cannot know that
no type (even not in a dependent crate) will implement <code>IsNot&lt;Self&gt;</code>.
Not implementing <code>IsNot&lt;Self&gt;</code> is just a convention,
it is not compiler-enforced and the compiler cannot see
this. To work around this, you can use the <a href="https://docs.rs/syllogism/0.1.0/syllogism/trait.Specialize.html"><code>Specialize</code></a> trait from the
<a href="https://docs.rs/syllogism/0.1.0/syllogism/"><code>syllogism</code></a> crate:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rsynth</span>::<span class="ident">event</span>::<span class="ident">EventHandler</span>;
<span class="kw">use</span> <span class="ident">syllogism</span>::{<span class="ident">Specialize</span>, <span class="ident">Distinction</span>};
<span class="kw">struct</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span> {
    <span class="ident">child</span>: <span class="ident">P</span>
}

<span class="comment">// If you are also supporting specialization as described above,</span>
<span class="comment">// this should be behind the `#[cfg(feature = &quot;stable&quot;)]` attribute.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">P</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyMiddleware</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">P</span>: <span class="ident">EventHandler</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">C</span><span class="op">&gt;</span> , <span class="ident">E</span>: <span class="ident">Specialize</span><span class="op">&lt;</span><span class="ident">SpecialEventType</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">handle_event</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">event</span>: <span class="ident">E</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">C</span>) {
        <span class="kw">match</span> <span class="ident">event</span>.<span class="ident">specialize</span>() {
            <span class="ident">Distinction</span>::<span class="ident">Special</span>(<span class="ident">special</span>) <span class="op">=&gt;</span> {
                <span class="comment">// Do something special</span>
            },
            <span class="ident">Distinction</span>::<span class="ident">Generic</span>(<span class="ident">generic</span>) <span class="op">=&gt;</span> {
                <span class="comment">// self.child.handle_event(generic, context);</span>
            }
        }
    }
}</pre></div>
<h2 id="writing-special-events-for-the-middleware" class="section-header"><a href="#writing-special-events-for-the-middleware">Writing special events for the middleware</a></h2>
<p>See <a href="./index.html#writing-events">&quot;Writing events&quot; below</a>.</p>
<h2 id="publishing-a-middleware-crate" class="section-header"><a href="#publishing-a-middleware-crate">Publishing a middleware crate</a></h2>
<p>When you publish a middleware crate, let us know by opening an issue or pull request
so that we can link to it in the documentation of <code>rsynth</code>.</p>
<h1 id="writing-events" class="section-header"><a href="#writing-events">Writing events</a></h1><h2 id="implement-copy-if-possible" class="section-header"><a href="#implement-copy-if-possible">Implement <code>Copy</code> if possible</a></h2>
<p>If possible, implement the <code>Copy</code> trait for the event,
so that the <code>Polyphonic</code> middleware can dispatch this event to all the voices.</p>
<h2 id="compatibility" class="section-header"><a href="#compatibility">Compatibility</a></h2>
<p>In order to allow specialization for the middleware (see above),
any event type <code>T1</code> needs to implement</p>
<ul>
<li><code>IsNot&lt;T2&gt;</code> for every event type <code>T2</code> that differs from <code>T1</code></li>
<li><code>Specialize&lt;T&gt;</code> for every event type <code>T</code>, including <code>T1</code> itself.</li>
</ul>
<p>Here &quot;every event type&quot; also needs to include event types defined in other crates that you may
or may not know about. In order to make this possible, open an issue for <code>rsynth</code> announcing
that you want to develop a crate and we can provide you</p>
<ul>
<li>a trait that is implemented for all event types defined outside your crate</li>
<li>a macro that you should use for all event types defined in your crate.</li>
</ul>
<p>In the meanwhile, you can use the trait <code>NotInUnpublishedCrate</code> and the macro
<code>macro_for_unpublished_crate</code>.</p>
<p>Please note that there are some subtleties around defining events with conditional compilation.
If you are planning to define some events only when some compile-time conditions are met,
please state so in the issue and we can discuss how we will handle this.</p>
<h3 id="compatibility-in-the-manual-way" class="section-header"><a href="#compatibility-in-the-manual-way">Compatibility in the manual way</a></h3>
<p>You can manually implement <code>IsNot</code> and <code>Specialize</code> as follows.
We include this documentation for clarity; in practice, you may want
to use the macro's as explained below in order to lower the risk that
you forget something.</p>
<h4 id="implementing-isnot-by-hand" class="section-header"><a href="#implementing-isnot-by-hand">Implementing <code>IsNot</code> by hand</a></h4>
<p>If you declare more than one event type, you need to ensure that each
event type implements <code>IsNot</code> of each other. Suppose that you can
use the trait <code>NotInMyCrate</code> and the macro <code>macro_for_my_crate</code>,
then you can ensure by hand that <code>IsNot</code> is implemented:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">syllogism</span>::<span class="ident">IsNot</span>;
<span class="kw">struct</span> <span class="ident">EventType1</span> {}
<span class="kw">struct</span> <span class="ident">EventType2</span> {}
<span class="kw">struct</span> <span class="ident">EventType3</span> {}

<span class="kw">impl</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">EventType2</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType1</span> {}
<span class="kw">impl</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">EventType3</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType1</span> {}
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType1</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">NotInMyCrate</span> {}
<span class="macro">macro_for_my_crate</span><span class="macro">!</span>(<span class="kw">impl</span> <span class="kw">trait</span> <span class="kw">for</span> <span class="ident">EventType1</span>);

<span class="kw">impl</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">EventType1</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType2</span> {}
<span class="kw">impl</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">EventType3</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType2</span> {}
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType2</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">NotInMyCrate</span> {}
<span class="macro">macro_for_my_crate</span><span class="macro">!</span>(<span class="kw">impl</span> <span class="kw">trait</span> <span class="kw">for</span> <span class="ident">EventType2</span>);

<span class="kw">impl</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">EventType1</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType3</span> {}
<span class="kw">impl</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">EventType2</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType3</span> {}
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">IsNot</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType3</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">NotInMyCrate</span> {}
<span class="macro">macro_for_my_crate</span><span class="macro">!</span>(<span class="kw">impl</span> <span class="kw">trait</span> <span class="kw">for</span> <span class="ident">EventType3</span>);</pre></div>
<h4 id="implementing-specialize-by-hand" class="section-header"><a href="#implementing-specialize-by-hand">Implementing <code>Specialize</code> by hand</a></h4>
<p>Each event type needs to implement <code>Specialize&lt;Self&gt;</code>.
Additionally, if you declare more than one event type, you need to ensure that each
event type implements <code>Specialize</code> of each other.
Suppose that you can
use the trait <code>NotInMyCrate</code> and the macro <code>macro_for_my_crate</code>, then you can ensure by hand
that <code>Specialize</code> is implemented:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">syllogism</span>::{<span class="ident">Specialize</span>, <span class="ident">Distinction</span>};
<span class="kw">struct</span> <span class="ident">EventType1</span> {}
<span class="kw">struct</span> <span class="ident">EventType2</span> {}
<span class="kw">struct</span> <span class="ident">EventType3</span> {}

<span class="kw">impl</span> <span class="ident">Specialize</span><span class="op">&lt;</span><span class="ident">EventType1</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType1</span> {
    <span class="kw">fn</span> <span class="ident">specialize</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Distinction</span><span class="op">&lt;</span><span class="ident">EventType1</span>, <span class="self">Self</span><span class="op">&gt;</span> {
        <span class="ident">Distinction</span>::<span class="ident">Special</span>(<span class="self">self</span>)
    }
}
<span class="kw">impl</span> <span class="ident">Specialize</span><span class="op">&lt;</span><span class="ident">EventType2</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType1</span> {
    <span class="kw">fn</span> <span class="ident">specialize</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Distinction</span><span class="op">&lt;</span><span class="ident">EventType2</span>, <span class="self">Self</span><span class="op">&gt;</span> {
        <span class="ident">Distinction</span>::<span class="ident">Generic</span>(<span class="self">self</span>)
    }
}
<span class="kw">impl</span> <span class="ident">Specialize</span><span class="op">&lt;</span><span class="ident">EventType3</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType1</span> {
    <span class="kw">fn</span> <span class="ident">specialize</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Distinction</span><span class="op">&lt;</span><span class="ident">EventType3</span>, <span class="self">Self</span><span class="op">&gt;</span> {
        <span class="ident">Distinction</span>::<span class="ident">Generic</span>(<span class="self">self</span>)
    }
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Specialize</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">EventType1</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">NotInMyCrate</span> {
    <span class="kw">fn</span> <span class="ident">specialize</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Distinction</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="self">Self</span><span class="op">&gt;</span> {
        <span class="ident">Distinction</span>::<span class="ident">Generic</span>(<span class="self">self</span>)
    }
}
<span class="macro">macro_for_my_crate</span><span class="macro">!</span>(<span class="kw">impl</span> <span class="kw">trait</span> <span class="kw">for</span> <span class="ident">EventType1</span>);

<span class="comment">// And similar for `EventType2` and `EventType3`, I&#39;m omitting this for brevity.</span></pre></div>
<h3 id="compatibility-by-using-the-macros-from-syllogism-macro" class="section-header"><a href="#compatibility-by-using-the-macros-from-syllogism-macro">Compatibility by using the macros from <code>syllogism-macro</code></a></h3>
<p>Most of the implementations of <code>IsNot</code> and <code>Specialize</code> can be done by using
the macro <a href="https://docs.rs/syllogism-macro/0.1.0/syllogism_macro/macro.impl_specialization.html"><code>impl_specialization</code></a> from the <code>syllogism-macro</code> crate:
under the same assumptions as above, this can be simplified
to the following (but see the note below for types with type parameters):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">syllogism_macro</span>::<span class="ident">impl_specialization</span>;
<span class="kw">struct</span> <span class="ident">EventType1</span> {}
<span class="kw">struct</span> <span class="ident">EventType2</span> {}
<span class="kw">struct</span> <span class="ident">EventType3</span> {}

<span class="macro">impl_specialization</span><span class="macro">!</span>(
    <span class="kw">trait</span> <span class="ident">NotInMyCrate</span>;
    <span class="kw">macro</span> <span class="ident">macro_for_my_crate</span>;

    <span class="kw">type</span> <span class="ident">EventType1</span>;
    <span class="kw">type</span> <span class="ident">EventType2</span>;
    <span class="kw">type</span> <span class="ident">EventType3</span>;
);</pre></div>
<p>The caveats are that for types with type parameters, you still need to implement <code>Specialize</code>
by hand and if you have more types with type parameters, you must use different names for
the type parameters in the call to the <a href="https://docs.rs/syllogism-macro/0.1.0/syllogism_macro/macro.impl_specialization.html"><code>impl_specialization</code></a> macro.
For more information, see the documentation of <a href="https://docs.rs/syllogism-macro/0.1.0/syllogism_macro/macro.impl_specialization.html"><code>impl_specialization</code></a>.</p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="transparent/index.html" title='rsynth::dev_utilities::transparent mod'>transparent</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="mod" href="vecstorage/index.html" title='rsynth::dev_utilities::vecstorage mod'>vecstorage</a></td><td class='docblock-short'><p><code>VecStorage</code> and <code>VecStorageMut</code></p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "rsynth";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>